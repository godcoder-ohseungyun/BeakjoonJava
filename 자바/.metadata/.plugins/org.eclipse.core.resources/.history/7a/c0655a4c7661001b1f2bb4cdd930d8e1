package Baekjoon_DFS_BFS;
import java.util.*;
import java.io.*;
/**
 * 
 * @해설 : 잘못품 그래프의 연결 검사 알고리즘이 x 해당 지도는 대칭 구조가 아님으로 방향이있는 간선의 개념임 따라서 양방향 성을 띌때 사용되는 연결 검사 알고리즘은 답을 맞춰낼수 x
 * but 이 건 잘했음
 *
 */
public class Main3 {
	
	private static LinkedList<LinkedList<Integer>> listIfo= new LinkedList<>();
	private static LinkedList<Integer> vertx = new LinkedList<>(); //정보 삽입이 잦음으로 LinkedList가 효과적
    private static LinkedList<LinkedList<Integer>> colored = new LinkedList<>(); //단지 묶음의 집합
    private static LinkedList<Integer> color = new LinkedList<>(); //아파트 묶음
	private static ArrayList<Integer> visited = new ArrayList<>(); //정보 참조를 자주 함으로 ArrayList가 효과적
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw =  new BufferedWriter(new OutputStreamWriter(System.out));
		int T = Integer.parseInt(br.readLine());
		String[] toList;
		
		
		
		for(int i=0;i<T;i++) {
			toList=br.readLine().split("");
			
			for(int index=0;index<toList.length;index++) {
				if(toList[index].equals("1")) {
					vertx.add(index);
				}
			}
			listIfo.add((LinkedList<Integer>) vertx.clone());
			vertx.clear(); //문제 => 참조가 같아버림 복사본이 필요함..!
		}
		//ㄴ> 모든 정보 인접 리스트화 "정점-1" 로 좌표 표기
		//System.out.println(listIfo.get(0).size()+"");
		
		for(int i=0;i<T;i++) { //정점 수 만큼 반복
			if(!visited.contains(i)) { //i는 현재 정점
				dfs(i);
				colored.add((LinkedList<Integer>) color.clone());
				color.clear(); //문제
			}
		}
		int size =  colored.size();
		
		bw.write(size+"\n");
		
		for(int i=0;i<size;i++) {
			bw.write(colored.get(i).size()+"\n");
		}
		
		bw.newLine();
		bw.flush();
		bw.close();
	}
	
	private static void dfs(int i) {
		
		visited.add(i);
		color.add(i);
		
		for(int index:listIfo.get(i)) {
			if(!visited.contains(index)) {
				dfs(index);
			}
		}
		
		
	}

}
